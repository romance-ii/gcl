(push :common-lisp *features*)
(push :ansi-cl *features*)
  
(make-package "COMPILER" :use '("LISP"))
(make-package "SLOOP" :use '("LISP"))
(make-package "SERROR" :use '("LISP" "SLOOP"))
(make-package "ANSI-LOOP" :use '("LISP"))
(make-package "DEFPACKAGE" :use '("LISP"))
(make-package "TK" :use '("LISP" "SLOOP"))
(make-package "MPI" :use '("LISP" "SLOOP"))
(make-package "JAPI-PRIMITIVES" :use '("LISP"))
(make-package "TK-PRIMITIVES" :use '("LISP"))
#+win32(make-package :WIN32-PRIMITIVES :use '("LISP"))
@LI-PCL-PACKAGE@

(in-package :pcl)
(defvar *the-pcl-package* (find-package :pcl))
(defun load-truename (&optional (errorp nil))
  (flet () *load-pathname* nil))

@LI-CLCS-PACKAGE@

(rename-package 'user 'common-lisp-user '(cl-user user))

(in-package "SYSTEM")

(defvar *command-args* nil)
 ;; if ANY header or license information is printed by the
 ;; program, then the following License and Enhancement notice
 ;; must be printed (see License).
(progn 

 (system:init-system) 
 (gbc t)

(progn
  (in-package 'lisp)
;; FIXME integrate this into the stream objects et.al. and/or
;; just use defclass
;  (defstruct (UNBOUND-SLOT (:constructor %make-UNBOUND-SLOT)))
;  (defstruct ( TWO-WAY-STREAM (:constructor %make-TWO-WAY-STREAM)))
;  (defstruct ( SYNONYM-STREAM (:constructor %make-SYNONYM-STREAM)))
;  (defstruct ( STYLE-WARNING (:constructor %make-STYLE-WARNING)))
;  (defstruct ( STRING-STREAM (:constructor %make-STRING-STREAM)))
;  (defstruct ( STREAM (:constructor %make-STREAM)))
;  (defstruct ( READTABLE (:constructor %make-READTABLE) (:copier %copy-readtable)))
;  (defstruct ( READER-ERROR (:constructor %make-READER-ERROR)))
;  (defstruct ( RANDOM-STATE (:constructor %make-RANDOM-STATE) (:predicate %random-state-p)))
;  (defstruct ( PRINT-NOT-READABLE (:constructor %make-PRINT-NOT-READABLE)))
;  (defstruct (PATHNAME (:constructor %make-PATHNAME)))
;  (defstruct ( PACKAGE (:constructor %make-PACKAGE)))
;  (defstruct ( LOGICAL-PATHNAME (:constructor %make-LOGICAL-PATHNAME)))
;  (defstruct ( HASH-TABLE (:constructor %make-HASH-TABLE) (:predicate %hash-table-p)))
;  (defstruct ( FUNCTION (:constructor %make-FUNCTION)))
;  (defstruct (FLOATING-POINT-INVALID-OPERATION (:constructor %make-FLOATING-POINT-INVALID-OPERATION)))
;  (defstruct ( FLOATING-POINT-INEXACT (:constructor %make-FLOATING-POINT-INEXACT)))
;  (defstruct ( FILE-STREAM (:constructor %make-FILE-STREAM)))
;  (defstruct (ECHO-STREAM (:constructor %make-ECHO-STREAM)))
;  (defstruct ( CONCATENATED-STREAM (:constructor %make-CONCATENATED-STREAM)))
;  (defstruct ( BROADCAST-STREAM (:constructor %make-BROADCAST-STREAM))))
)

 (in-package "USER")

 (or lisp::*link-array*
     (setq lisp::*link-array*
	   (make-array (ash 1 11)  :element-type 'character :fill-pointer 0)))
 (si::use-fast-links t)

 (let* ((x (append (pathname-directory si::*system-directory*) (list :parent)))
	(lsp (append x (list "lsp")))
	(cmpnew (append x (list "cmpnew")))
	(h (append x (list "h")))
	(pcl (append x (list "pcl")))
	(clcs (append x (list "clcs")))
	(gtk (append x (list "gcl-tk"))))
   (dolist (d (list lsp cmpnew pcl clcs))
       (load (make-pathname :name "sys-proclaim" :type "lisp" :directory d)))
   (load (make-pathname :name "tk-package" :type "lsp" :directory gtk))
;   (load (make-pathname :name "gcl_cmpmain" :type "lsp" :directory cmpnew))
   (load (make-pathname :name "gcl_lfun_list" :type "lsp" :directory cmpnew))
   (load (make-pathname :name "gcl_cmpopt" :type "lsp" :directory cmpnew))
   (load (make-pathname :name "gcl_auto_new" :type "lsp" :directory lsp))

   (gbc t)

   (setq compiler::*cmpinclude* "\"cmpinclude.h\"") 
 
   (when compiler::*cmpinclude-string*
     (with-open-file (st (make-pathname :directory h :name "cmpinclude" :type "h"))
		     (let
			 ((tem (make-array (file-length st) :element-type 'standard-char
					   :static t)))
		       (if (si::fread tem 0 (length tem) st)
			   (setq compiler::*cmpinclude-string* tem))))))
 
 (setf (symbol-function 'si:clear-compiler-properties)
       (symbol-function 'compiler::compiler-clear-compiler-properties))
 (setq system::*old-top-level* (symbol-function 'system:top-level))
 
 (defvar si::*lib-directory* (namestring (make-pathname :directory (list :parent))))
 
 (defun system::gcl-top-level (&aux tem)
   (si::set-up-top-level)
   
   (if (si::get-command-arg "-compile")
       (let (;(system::*quit-tag* (cons nil nil))
		;(system::*quit-tags* nil) (system::*break-level* '())
		;(system::*break-env* nil) (system::*ihs-base* 1)
		;(system::*ihs-top* 1) (system::*current-ihs* 1)
	     (*break-enable* nil) result)
	 (setq result
	       (system:error-set
		'(progn
		   (compile-file
		    (si::get-command-arg "-compile")
		    :output-file 
		    (or (si::get-command-arg "-o")
			(si::get-command-arg "-compile"))
		    :o-file
		    (cond ((equalp
			    (si::get-command-arg "-o-file")
			    "nil") nil)
			  ((si::get-command-arg "-o-file" t))
			  (t t))
		    :c-file (si::get-command-arg "-c-file" t)
		    :h-file (si::get-command-arg "-h-file" t)
		    :data-file (si::get-command-arg "-data-file" t)
		    :system-p (si::get-command-arg "-system-p" t)))))
	 (bye (if (or compiler::*error-p* (equal result '(nil))) 1 0))))
   (cond ((si::get-command-arg "-batch")
	  (setf si::*top-level-hook* #'si::bye))
	 ((si::get-command-arg "-f"))
	 (t (format t si::*system-banner*)
	    (let* ((c (find-package "COMPILER"))
		   (tmp (and c (find-symbol "*TMP-DIR*" c))))
	      (when tmp
		(setf (symbol-value tmp) (funcall (find-symbol "GET-TEMP-DIR" c)))
	(format t "Temporary directory for compiler files set to ~a~%" (symbol-value tmp))))))
   (setq si::*ihs-top* 1)
   (in-package 'system::user) (incf system::*ihs-top* 2)
   (funcall system::*old-top-level*))
 
 (terpri)
 (setq si:*inhibit-macro-special* t)
 (gbc t) (system:reset-gbc-count)
 
 (defun system:top-level nil (system::gcl-top-level))
 
 (setq compiler::*default-c-file* nil)
 (setq compiler::*default-h-file* nil)
 (setq compiler::*default-data-file* nil)
 (setq compiler::*default-system-p* nil)
 (setq compiler::*keep-gaz* nil)
 
 (setq clcs_shadow
       '(CONDITIONS::BREAK
	 CONDITIONS::ERROR
	 CONDITIONS::CERROR
	 CONDITIONS::WARN
	 CONDITIONS::CHECK-TYPE
	 CONDITIONS::ASSERT
	 CONDITIONS::ETYPECASE
	 CONDITIONS::CTYPECASE
	 CONDITIONS::ECASE
	 CONDITIONS::CCASE ))
 
 (setq lisp_unexport
       '(LISP::LAMBDA-BLOCK-CLOSURE
	 LISP::BYE
	 LISP::QUIT
	 LISP::EXIT
	 LISP::IEEE-FLOATING-POINT
	 LISP::DEFENTRY
	 LISP::VOID
	 LISP::ALLOCATE-CONTIGUOUS-PAGES
	 LISP::UNSIGNED-SHORT
	 LISP::DOUBLE
	 LISP::BY
	 LISP::GBC
	 LISP::DEFCFUN
	 LISP::SAVE
	 LISP::MAXIMUM-CONTIGUOUS-PAGES
	 LISP::SPICE
	 LISP::DEFLA
	 LISP::ALLOCATED-PAGES
	 LISP::SUN
	 LISP::INT
	 LISP::USE-FAST-LINKS
	 LISP::CFUN
	 LISP::UNSIGNED-CHAR
	 LISP::HELP
	 LISP::HELP*
	 LISP::MACRO
	 LISP::*BREAK-ENABLE*
	 LISP::CLINES
	 LISP::LAMBDA-CLOSURE
	 LISP::OBJECT
	 LISP::FAT-STRING
	 LISP::SIGNED-SHORT
	 LISP::MC68020
	 LISP::LAMBDA-BLOCK
	 LISP::TAG
	 LISP::PROCLAMATION
	 LISP::ALLOCATED-CONTIGUOUS-PAGES
	 LISP::*EVAL-WHEN-COMPILE*
	 LISP::SIGNED-CHAR
	 LISP::*IGNORE-MAXIMUM-PAGES*
	 LISP::*LINK-ARRAY*
	 LISP::KCL
	 LISP::BSD
	 LISP::ALLOCATE-RELOCATABLE-PAGES
	 LISP::ALLOCATE
	 LISP::UNIX
	 LISP::MAXIMUM-ALLOCATABLE-PAGES
	 LISP::ALLOCATED-RELOCATABLE-PAGES
	 LISP::SYSTEM
	 LISP::KYOTO
	 LISP::CCLOSURE))
 


;anything in "SYSTEM" which should go in "COMMON-LISP"
;can be added to shadow-system
 (setf shadow-system '(system::copy-structure
	system::define-compiler-macro
	system::compiler-macro-function))
 
 (do-external-symbols (s "SYSTEM")
		      (when (member s shadow-system)
			(shadowing-import (list s) "COMMON-LISP")
			(shadowing-import (list s) "USER")))
 
 
 (do-external-symbols (s "LISP")
		      (if (not(member s lisp_unexport))
			  (progn 
			    (import (list s) "COMMON-LISP")
			    (import (list s) "USER")) ))
 
 (do-external-symbols 
  (s "PCL")
  (unless (member s '(pcl::STANDARD-SLOT-DEFINITION  
		      pcl::SLOT-DEFINITION pcl::SPECIALIZER 
		      pcl::EFFECTIVE-SLOT-DEFINITION pcl::STANDARD-WRITER-METHOD
		      pcl::STANDARD-READER-METHOD pcl::EQL-SPECIALIZER
		      pcl::DIRECT-SLOT-DEFINITION pcl::INTERPRETED-FUNCTION
		      pcl::FORWARD-REFERENCED-CLASS
		      pcl::STANDARD-EFFECTIVE-SLOT-DEFINITION
		      pcl::STANDARD-ACCESSOR-METHOD
		      pcl::STANDARD-DIRECT-SLOT-DEFINITION
		      pcl::FUNCALLABLE-STANDARD-CLASS))
    (import (list s) "COMMON-LISP")
    (import (list s) "USER")))

(shadowing-import (find-symbol "DOCUMENTATION" 'pcl) 'common-lisp)
(shadowing-import (find-symbol "DOCUMENTATION" 'pcl) 'user)
 
 
;(shadowing-import (list 'pcl::classp) "SYSTEM")
; (setf (symbol-function 'si::classp) (symbol-function 'pcl::classp))
; (setf (symbol-function 'si::class-of) (symbol-function 'pcl::class-of))
; (setf (symbol-function 'si::class-precedence-list) 
;       (symbol-function 'pcl::class-precedence-list))
; (setf (symbol-function 'si::find-class) 
;       (symbol-function 'pcl::find-class))
; (setf (symbol-function 'si::find-class-no-error) 
;	(symbol-function 'conditions::find-class-no-error))

 (do-external-symbols 
  (s "CONDITIONS")
  (unless (member s '(conditions::STACK-OVERFLOW conditions::STORAGE-EXHAUSTED))
    (if (member s clcs_shadow)
	(progn 
	  (shadowing-import (list s) "COMMON-LISP")
	  (shadowing-import (list s) "USER"))
      (progn
	(import (list s) "COMMON-LISP")
	(import (list s) "USER")))))
 
 (do-external-symbols (s "COMPILER")
		      (if (member s clcs_shadow)
			  (progn 
			    (shadowing-import (list s) "COMMON-LISP")
			    (shadowing-import (list s) "USER"))
			(progn
			  (import (list s) "COMMON-LISP")
			  (import (list s) "USER"))))

 (setf (symbol-function 'compiler::compile-file)
       (let ((old (symbol-function 'compiler::compile-file)))
	 (lambda (&rest args)
	   (let (warnings failures)
	     (conditions::handler-bind
	      ((warning (lambda (c) 
			 (setq warnings t) 
			 (unless (typep c 'style-warning)
			   (setq failures t))
			 (when (not compiler::*compile-verbose*) 
			   (conditions::invoke-restart 
			    (conditions::find-restart 'conditions::muffle-warning c)))))
	       (error (lambda (c) (setq failures t))))
	      (values (apply old args) warnings failures))))))
 t)

(progn

  (dolist (s '(*load-pathname* *load-print*
				       *load-truename* *print-lines* *print-miser-width*
				       *print-pprint-dispatch* *print-right-margin* *read-eval*
				       lisp::arithmetic-error broadcast-stream-streams cell-error
				       cell-error-name compile compile-file compiler-macro
				       compiler-macro-function complement concatenated-stream-streams
				       condition control-error copy-pprint-dispatch copy-structure count
				       debug define-compiler-macro define-setf-expander define-symbol-macro
				       defpackage describe describe-object division-by-zero dynamic-extent
				       ensure-directories-exist fdefinition file-string-length formatter
				        get-setf-expansion hash-table-rehash-size
				       hash-table-rehash-threshold interactive-stream-p
				        make-load-form
				        make-method pathname-match-p
				       pprint-dispatch  print-not-readable-object
				       print-unreadable-object 
				       set-pprint-dispatch simple-condition-format-control
				       stream-external-format synonym-stream-symbol
				       translate-logical-pathname translate-pathname
				       unbound-slot-instance 
				       upgraded-complex-part-type wild-pathname-p with-compilation-unit
				       with-condition-restarts 
				        ))
    (shadowing-import (list s) "COMMON-LISP"))
  
  (use-package "ANSI-LOOP" "COMMON-LISP")
  (use-package "ANSI-LOOP" "USER")
  
  (do-symbols (s "COMMON-LISP")
	      (export (list s) "COMMON-LISP"))
  
  (rename-package 'common-lisp 'common-lisp '(cl))
  
  (unintern 'system)
  (unintern 'lisp)
  (unintern 'compiler)
  (unintern 'user)
  (when (fboundp 'si::init-cmp-anon) (fmakunbound 'si::init-cmp-anon))
  
  (makunbound 'clcs_shadow)
  (makunbound 'lisp_unexport)
  (makunbound 'shadow-system)
  (unintern 'clcs_shadow)
  (unintern 'lisp_unexport)
  (unintern 'int)
  (unintern 'shadow-system)
  
;  (push :common-lisp *features*)
;  (push :ansi-cl *features*)
  
  (eval-when (load)
	     (if (fboundp 'get-system-time-zone)
		 (setf system:*default-time-zone* (get-system-time-zone))
	       (setf system:*default-time-zone* 6)))
  
  (if (fboundp 'si::user-init) (si::user-init))
  (si::set-up-top-level)
  
  (setq si::*gcl-extra-version* @LI-EXTVERS@
	si::*gcl-minor-version* @LI-MINVERS@ 
	si::*gcl-major-version* @LI-MAJVERS@)
  (setq compiler::*cc* @LI-CC@)
  (setq compiler::*ld* @LI-LD@)
  (setq compiler::*ld-libs* @LI-LD-LIBS@)
  (setq compiler::*opt-three* @LI-OPT-THREE@)
  (setq compiler::*opt-two* @LI-OPT-TWO@)
  (setq compiler::*init-lsp* @LI-INIT-LSP@)

  (defvar si::*system-banner* (si::default-system-banner))

  (in-package 'user)
  (import 'si::info)

  t)
